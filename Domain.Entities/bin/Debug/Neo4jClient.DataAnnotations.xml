<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neo4jClient.DataAnnotations</name>
    </assembly>
    <members>
        <member name="T:Neo4jClient.DataAnnotations.AnnotationsContext">
            <summary>
                The context class for entities.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.AnnotationsContext.GraphClient">
            <summary>
                The attached <see cref="T:Neo4jClient.IGraphClient" />
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityService">
            <summary>
                The attached <see cref="T:Neo4jClient.DataAnnotations.EntityService" />
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityResolver">
            <summary>
                The attached <see cref="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityResolver" />. This should be <code>null</code> if <see cref="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityConverter" /> is
                present.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityConverter">
            <summary>
                The attached <see cref="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityConverter" />. This should be <code>null</code> if <see cref="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityResolver" /> is
                present.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityResolverConverter">
            <summary>
                The attached <see cref="P:Neo4jClient.DataAnnotations.AnnotationsContext.EntityResolverConverter" /> used for deserialization purposes.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.AnnotationsContext.Cypher">
            <summary>
                A shortcut to the <see cref="P:Neo4jClient.ICypherGraphClient.Cypher" /> property.
            </summary>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions">
            <summary>
                To avoid method signature conflicts and clogging our intellisence, these were separated into another class.
                You can still use the <see cref="T:Neo4jClient.DataAnnotations.CypherFunctions" /> class as an aternative.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions._``1(``0)">
            <summary>
                No Further Processing. Naming and other processing escape. This instructs the expression visitors to use as
                specified.
                NOTE: This method does not affect serialization. So inner complex typed properties would still serialize to
                exploded properties as expected.
                This method is mainly used by the expression visitors, and mostly at the top surface level (rarely deep into the
                object).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions._As``1(System.Object)">
            <summary>
                Casts an object to a certain type so as to use its properties directly.
                Use only in expressions, especially with <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> method calls (in which case it
                Pseudo-casts).
                NOTE: THIS METHOD IS NOT SAFE TO EXECUTE. If the cast fails, it merely generates a default value for the return
                type.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions._AsList``1(System.Object)">
            <summary>
                Casts an object to a list of a certain type so as to use IEnumerable extension methods.
                Use only in expressions, especially with <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> method calls (in which case it
                Pseudo-casts).
                Shortcut for <code>._As&lt;List&lt;T&gt;&gt;()</code>
                NOTE: THIS METHOD IS NOT SAFE TO EXECUTE. If the cast fails, it throws an error.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions._AsList``1(``0)">
            <summary>
                Casts an object to a list of a certain type so as to use IEnumerable extension methods.
                Use only in expressions, especially with <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> method calls (in which case it
                Pseudo-casts).
                Shortcut for <code>._As&lt;List&lt;T&gt;&gt;()</code>
                NOTE: THIS METHOD IS NOT SAFE TO EXECUTE. If the cast fails, it merely returns a list having
                <paramref name="obj" /> as only item.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.IsNull``1(``0)">
            <summary>
                The neo4j <code>IS NULL</code> function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.IsNotNull``1(``0)">
            <summary>
                The neo4j <code>IS NOT NULL</code> function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Collect``1(``0)">
            <summary>
                The neo4j collect aggregator.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Length``1(``0)">
            <summary>
                The neo4j length function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Exists``1(``0)">
            <summary>
                The neo4j exists function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Size``1(``0)">
            <summary>
                The neo4j size function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Id``1(``0)">
            <summary>
                The neo4j id function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Type``1(``0)">
            <summary>
                The neo4j type function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Properties``1(``0)">
            <summary>
                The neo4j properties function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Average``1(``0)">
            <summary>
                The neo4j avg function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Max``1(``0)">
            <summary>
                The neo4j max function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Min``1(``0)">
            <summary>
                The neo4j min function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Sum``1(``0)">
            <summary>
                The neo4j sum function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.StartNode``1(System.Object)">
            <summary>
                The neo4j startNode function
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.EndNode``1(System.Object)">
            <summary>
                The neo4j endNode function
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Count``1(``0)">
            <summary>
                The neo4j count function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Keys``1(``0)">
            <summary>
                The neo4j keys function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Labels``1(``0)">
            <summary>
                The neo4j labels function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Nodes``1(System.Object)">
            <summary>
                The neo4j nodes function.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Relationships``1(System.Object)">
            <summary>
                The neo4j relationships function.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Distinct``1(``0)">
            <summary>
                The neo4j distinct function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.StandardDeviation``1(``0)">
            <summary>
                The neo4j stDev function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.StandardDeviationP``1(``0)">
            <summary>
                The neo4j stDevP function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.PercentileCont``1(``0,System.Double)">
            <summary>
                The neo4j percentileCont function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.PercentileDisc``1(``0,System.Double)">
            <summary>
                The neo4j percentileDisc function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Tail``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                The neo4j tail function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.None``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                The neo4j none function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Cypher.Functions.CypherExtensionFunctions.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                The neo4j single function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.Cypher.IAnnotatedQuery">
            <summary>
                Mostly dummy interface. It allows us to execute some cypher query methods with annotations.
            </summary>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.Cypher.IPattern">
            <summary>
                (A)-[R]-(B)
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Cypher.Pattern.AFinalProperties">
            <summary>
                This would contain the properties as they would be written to cypher.
                Variables would be a <see cref="T:Newtonsoft.Json.Linq.JRaw" /> value here, and not <see cref="T:Newtonsoft.Json.Linq.JValue" /> string.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Cypher.Pattern.AFinalObject">
            <summary>
                This would contain the properties as they would be written to cypher.
                Variables would be a <see cref="T:Newtonsoft.Json.Linq.JRaw" /> value here, and not <see cref="T:Newtonsoft.Json.Linq.JValue" /> string.
            </summary>
        </member>
        <member name="F:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy.NoParams">
            <summary>
                Writes the properties directly into the generated pattern.
                E.g. (a:Movie { title: "Grey's Anatomy", year: 2017 }
            </summary>
        </member>
        <member name="F:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy.WithParams">
            <summary>
                Stores the properties via a <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call, and replaces it with
                a parameter.
                E.g. (a:Movie { movie }), where "movie" is the parameter. This style can be used for the CREATE and CREATE UNIQUE
                statements.
                NOTE that if you have variables in your properties with this strategy set, <see cref="F:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy.WithParamsForValues" /> is
                used instead.
            </summary>
        </member>
        <member name="F:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy.WithParamsForValues">
            <summary>
                Stores the properties via a <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call, and replaces each
                property value with corresponding parameter property.
                E.g. (a:Movie { title: {movie}.title, year: {movie}.year }), where "movie" is the parameter. This style is
                applicable to the MATCH and OPTIONAL MATCH statements.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Cypher.QueryContext.CurrentQueryWriter">
            <summary>
                Note that this query writer is useless against subsequent <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> calls when the query
                object changes
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Cypher.QueryContext.CurrentBuildStrategy">
            <summary>
                Note that this build strategy might be is useless against subsequent <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> calls when
                the query object changes
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherAnnotatedQueryExtensions.OrderBy``1(Neo4jClient.DataAnnotations.Cypher.IAnnotatedQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.Cypher.ICypherResultItem,``0}})">
            <summary>
                Orders the query by a single property in ascending other.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="annotatedQuery"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherAnnotatedQueryExtensions.OrderByDescending``1(Neo4jClient.DataAnnotations.Cypher.IAnnotatedQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.Cypher.ICypherResultItem,``0}})">
            <summary>
                Orders the query by a single property in decending other.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="annotatedQuery"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherAnnotatedQueryExtensions.ThenBy``1(Neo4jClient.DataAnnotations.Cypher.IOrderedAnnotatedQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.Cypher.ICypherResultItem,``0}})">
            <summary>
                Orders the query by an additional property in ascending other.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="annotatedQuery"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherAnnotatedQueryExtensions.ThenByDescending``1(Neo4jClient.DataAnnotations.Cypher.IOrderedAnnotatedQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.Cypher.ICypherResultItem,``0}})">
            <summary>
                Orders the query by an additional property in descending other.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="annotatedQuery"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Match(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Generates a cypher MATCH statement from the pattern descriptions.
                E.g Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the Neo4j
                pattern: MATCH path=(a), (b)--&gt;(c).
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.OptionalMatch(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Generates a cypher OPTIONAL MATCH statement from the pattern descriptions.
                E.g Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the Neo4j
                pattern: OPTIONAL MATCH path=(a), (b)--&gt;(c).
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Merge(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Generates a cypher MERGE statement from the pattern descriptions.
                E.g Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the Neo4j
                pattern: MERGE path=(a), (b)--&gt;(c).
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Create(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Generates a cypher CREATE statement from the pattern descriptions.
                E.g Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the Neo4j
                pattern: CREATE path=(a), (b)--&gt;(c).
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.CreateUnique(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Generates a cypher CREATE UNIQUE statement from the pattern descriptions.
                E.g Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the Neo4j
                pattern: CREATE UNIQUE path=(a), (b)--&gt;(c).
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.AsAnnotatedQuery(Neo4jClient.Cypher.ICypherFluentQuery)">
            <summary>
                <see cref="T:Neo4jClient.DataAnnotations.Cypher.IAnnotatedQuery" /> abstracts methods that re-implement Neo4jClient methods using the same signatures in
                order to take advantage of annotations features like ComplexTypes.
                Separating these methods this way ensures that we avoid collisions.
                E.g. client.Cypher.AsAnnotatedQuery().Where((MovieNode movie) =&gt; movie.Year == 2017)
                See Tests for examples. Call <see cref="!:AnnotatedQueryExtensions.AsCypherQuery(IAnnotatedQuery)" /> to return to
                normal Cypher methods.
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.AsOrderedAnnotatedQuery(Neo4jClient.Cypher.IOrderedCypherFluentQuery)">
            <summary>
                <see cref="T:Neo4jClient.DataAnnotations.Cypher.IOrderedAnnotatedQuery" /> abstracts methods that re-implement Neo4jClient methods using the same
                signatures in order to take advantage of annotations features like ComplexTypes.
                Separating these methods this way ensures that we avoid collisions.
                E.g. client.Cypher.AsAnnotatedQuery().Where((MovieNode movie) =&gt; movie.Year == 2017)
                See Tests for examples. Call <see cref="!:AnnotatedQueryExtensions.AsCypherQuery(IOrderedAnnotatedQuery)" /> to
                return to normal Cypher methods.
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Clause(Neo4jClient.Cypher.ICypherFluentQuery,System.String)">
            <summary>
                Adds a cypher clause to the query.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="clauseText"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Clause``1(Neo4jClient.Cypher.ICypherFluentQuery,System.String)">
            <summary>
                Adds a cypher clause to the query.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="clauseText"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.OrderedClause(Neo4jClient.Cypher.ICypherFluentQuery,System.String)">
            <summary>
                Adds an ordered cypher clause to the query.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="orderedClauseText"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.OrderedClause``1(Neo4jClient.Cypher.ICypherFluentQuery,System.String)">
            <summary>
                Adds an ordered cypher clause to the query.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="orderedClauseText"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Mutate(Neo4jClient.Cypher.ICypherFluentQuery,System.Action{Neo4jClient.Cypher.QueryWriter})">
            <summary>
                Mutates the <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> after modifying some <see cref="T:Neo4jClient.Cypher.QueryWriter" /> parameters.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Mutate``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Action{Neo4jClient.Cypher.QueryWriter})">
            <summary>
                Mutates the <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> after modifying some <see cref="T:Neo4jClient.Cypher.QueryWriter" /> parameters.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.MutateOrdered(Neo4jClient.Cypher.ICypherFluentQuery,System.Action{Neo4jClient.Cypher.QueryWriter})">
            <summary>
                Mutates the <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> into an <see cref="T:Neo4jClient.Cypher.IOrderedCypherFluentQuery" /> after modifying some
                <see cref="T:Neo4jClient.Cypher.QueryWriter" /> parameters.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.MutateOrdered``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Action{Neo4jClient.Cypher.QueryWriter})">
            <summary>
                Mutates the <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> into an <see cref="T:Neo4jClient.Cypher.IOrderedCypherFluentQuery" /> after modifying some
                <see cref="T:Neo4jClient.Cypher.QueryWriter" /> parameters.
                NOTE: ENSURE YOU HAVE A UNIQUE USE CASE BEFORE USING HERE.
            </summary>
            <param name="query"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithPattern(Neo4jClient.Cypher.ICypherFluentQuery,System.String@,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Builds Neo4j pattern with <see cref="F:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy.WithParamsForValues" /> as default strategy.
                If multiple patterns are described, they are concatenated with a comma.
                E.g., Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the
                Neo4j pattern: path=(a), (b)--&gt;(c).
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="pattern">Pattern generated using the specified strategy and existing query object.</param>
            <param name="patternDescriptions"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithPattern(Neo4jClient.Cypher.ICypherFluentQuery,System.String@,Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.Cypher.IPathBuilder,Neo4jClient.DataAnnotations.Cypher.IPathExtent}}[])">
            <summary>
                Builds Neo4j pattern using the specified <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" />. If multiple patterns are
                described, they are concatenated with a comma.
                E.g., Given: (path) =&gt; path.Pattern("a").Assign(), (path2) =&gt; path2.Pattern("b", "c"), you should get the
                Neo4j pattern: path=(a), (b)--&gt;(c).
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="pattern">Pattern generated using the specified strategy and existing query object.</param>
            <param name="defaultBuildStrategy"><see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> option to use.</param>
            <param name="patternDescriptions"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithExpression``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String[]@)">
            <summary>
                Gets the specified variable expression as they would be used in Neo4j.
                E.g., query.WithExpression((Person person) =&gt; person.Address.City, out var values), should get you an expression
                like: person.address_city.
                A complex expression like query.WithExpression((Person person) =&gt; person.Address.City.ToString().Length, out var
                values), gets you: size(toString(person.addres_city)).
                For multiple expressions of same type, query.WithExpression((Person person) =&gt; new { person.Name.ToLower(),
                person.Address.City }, out var values).
                Camel casing is assumed for the examples. The complex expressions are mostly limited to Neo4j string functions for
                now.
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="expressions"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithExpression``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String[]@,System.String)">
            <summary>
                Gets the specified variable expression as they would be used in Neo4j.
                E.g., query.WithExpression((Person person) =&gt; person.Address.City, out var values), should get you an expression
                like: person.address_city.
                A complex expression like query.WithExpression((Person person) =&gt; person.Address.City.ToString().Length, out var
                values), gets you: size(toString(person.addres_city)).
                For multiple expressions of same type, query.WithExpression((Person person) =&gt; new { person.Name.ToLower(),
                person.Address.City }, out var values).
                Camel casing is assumed for the examples. The complex expressions are mostly limited to Neo4j string functions for
                now.
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="expressions"></param>
            <param name="values"></param>
            <param name="variable">
                Overrides the parameter used in the lambda. This is useful if the actual variable is only known
                at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithExpression``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String[]@,System.Boolean)">
            <summary>
                Gets the specified variable expression as they would be used in Neo4j.
                E.g., query.WithExpression((Person person) =&gt; person.Address.City, out var values), should get you an expression
                like: person.address_city.
                A complex expression like query.WithExpression((Person person) =&gt; person.Address.City.ToString().Length, out var
                values), gets you: size(toString(person.addres_city)).
                For multiple expressions of same type, query.WithExpression((Person person) =&gt; new { person.Name.ToLower(),
                person.Address.City }, out var values).
                Camel casing is assumed for the examples. The complex expressions are mostly limited to Neo4j string functions for
                now.
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="expressions"></param>
            <param name="values"></param>
            <param name="isMemberAccess">
                If false, the variable is omitted in the returned names.
                E.g., name, address_city. Default is true.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithExpression``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String[]@,System.Boolean,System.String)">
            <summary>
                Gets the specified variable expression as they would be used in Neo4j.
                E.g., query.WithExpression((Person person) =&gt; person.Address.City, out var values), should get you an expression
                like: person.address_city.
                A complex expression like query.WithExpression((Person person) =&gt; person.Address.City.ToString().Length, out var
                values), gets you: size(toString(person.addres_city)).
                For multiple expressions of same type, query.WithExpression((Person person) =&gt; new { person.Name.ToLower(),
                person.Address.City }, out var values).
                Camel casing is assumed for the examples. The complex expressions are mostly limited to Neo4j string functions for
                now.
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="expressions"></param>
            <param name="values"></param>
            <param name="isMemberAccess">
                If false, the parameter is omitted in the returned expressions.
                That is, instead of "person.name", you get just "name". Default is true.
            </param>
            <param name="variable">
                Overrides the parameter used in the lambda. This is useful if the actual variable is only known
                at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.WithExpression``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String[]@,System.Boolean,System.String,Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy)">
            <summary>
                Gets the specified variable expression as they would be used in Neo4j.
                E.g., query.WithExpression((Person person) =&gt; person.Address.City, out var values), should get you an expression
                like: person.address_city.
                A complex expression like query.WithExpression((Person person) =&gt; person.Address.City.ToString().Length, out var
                values), gets you: size(toString(person.addres_city)).
                For multiple expressions of same type, query.WithExpression((Person person) =&gt; new { person.Name.ToLower(),
                person.Address.City }, out var values).
                Camel casing is assumed for the examples. The complex expressions are mostly limited to Neo4j string functions for
                now.
                This method allows you to safely chain calls on an existing <see cref="T:Neo4jClient.Cypher.ICypherFluentQuery" /> object.
            </summary>
            <param name="query"></param>
            <param name="expressions"></param>
            <param name="values"></param>
            <param name="isMemberAccess">
                If false, the parameter is omitted in the returned expressions.
                That is, instead of "person.name", you get just "name". Default is true.
            </param>
            <param name="variable">
                Overrides the parameter used in the lambda. This is useful if the actual variable is only known
                at runtime (dynamic).
            </param>
            <param name="defaultBuildStrategy">
                Set a build strategy in the event that it unexpectedly encounters a constant
                expression.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.UsingBuildStrategy(Neo4jClient.Cypher.ICypherFluentQuery,System.Nullable{Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy})">
            <summary>
                Assigns a specific <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> value to be used with all clause/statement calls.
                This value is set until you change it again.
                Pass null to this method to reset it and use the default build strategy for each clause.
                E.g., query.UsingBuildStrategy(PropertiesBuildStrategy.WithParams).Match(...).
                The build strategy used after this call is now <see cref="F:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy.WithParams" />.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="buildStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Set(Neo4jClient.Cypher.ICypherFluentQuery,System.String,System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                Generates a cypher SET statement from the properties.
                E.g. () =&gt; new Movie { title = "Grey's Anatomy", year = 2017 }, should generate: SET movie = { title: "Grey's
                Anatomy", year = 2017 }, where movie is the variable.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Set(Neo4jClient.Cypher.ICypherFluentQuery,System.String,System.Linq.Expressions.Expression{System.Func{System.Object}},System.String@)">
            <summary>
                Generates a cypher SET statement from the properties.
                E.g. () =&gt; new Movie { title = "Grey's Anatomy", year = 2017 }, should generate: SET movie = { title: "Grey's
                Anatomy", year = 2017 }, where movie is the variable.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Set``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Generates a cypher SET statement from the predicate.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie.title =
                "Grey's Anatomy", movie.year = 2017.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Set``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
                Generates a cypher SET statement from the predicate.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie.title =
                "Grey's Anatomy", movie.year = 2017.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="variable">
                Overrides the parameter used in the predicate lambda. This is useful if the actual variable is
                only known at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Set``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String@)">
            <summary>
                Generates a cypher SET statement from the predicate.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie.title =
                "Grey's Anatomy", movie.year = 2017.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.Set``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String@,System.String)">
            <summary>
                Generates a cypher SET statement from the predicate.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie.title =
                "Grey's Anatomy", movie.year = 2017.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <param name="variable">
                Overrides the parameter used in the predicate lambda. This is useful if the actual variable is
                only known at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.SetAdd``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Generates a cypher SET statement from the predicate using the "+=" operator.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie += {
                title: "Grey's Anatomy", year = 2017 }.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.SetAdd``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
                Generates a cypher SET statement from the predicate using the "+=" operator.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie += {
                title: "Grey's Anatomy", year = 2017 }.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="variable">
                Overrides the parameter used in the predicate lambda. This is useful if the actual variable is
                only known at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.SetAdd``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String@)">
            <summary>
                Generates a cypher SET statement from the predicate using the "+=" operator.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie += {
                title: "Grey's Anatomy", year = 2017 }.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.SetAdd``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String@,System.String)">
            <summary>
                Generates a cypher SET statement from the predicate using the "+=" operator.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie += {
                title: "Grey's Anatomy", year = 2017 }.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <param name="variable">
                Overrides the parameter used in the predicate lambda. This is useful if the actual variable is
                only known at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.SharedSet(Neo4jClient.Cypher.ICypherFluentQuery,System.String,System.Linq.Expressions.LambdaExpression,Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy,System.String@,System.Boolean)">
            <summary>
                Generates a cypher SET statement from the properties.
                E.g. () =&gt; new Movie { title = "Grey's Anatomy", year = 2017 }, should generate: SET movie = { title: "Grey's
                Anatomy", year = 2017 }, where movie is the variable.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <param name="add">If this is set to true, the SET statement would use the '+=' operator and not the '=' operator.</param>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.SharedSet``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy,System.String@,System.String)">
            <summary>
                Generates a cypher SET statement from the predicate.
                E.g. movie =&gt; movie.title = "Grey's Anatomy" &amp;&amp; movie.year = 2017, should generate: SET movie.title =
                "Grey's Anatomy", movie.year = 2017.
                The <see cref="T:Neo4jClient.DataAnnotations.Cypher.PropertiesBuildStrategy" /> used could slightly modify the statement generated.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="predicate"></param>
            <param name="setParameter">The parameter used in the <see cref="M:Neo4jClient.Cypher.ICypherFluentQuery.WithParam(System.String,System.Object)" /> call.</param>
            <param name="variable">
                Overrides the parameter used in the predicate lambda. This is useful if the actual variable is
                only known at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.OrderBy``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Orders the query by a property in ascending order.
                E.g., query.OrderBy((Actor actor) => actor.Name) generates the cypher: ORDER BY actor.name.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.OrderByDescending``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Orders the query by a property in descending order.
                E.g., query.OrderByDescending((Actor actor) => actor.Name) generates the cypher: ORDER BY actor.name DESC.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.ThenBy``1(Neo4jClient.Cypher.IOrderedCypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Orders the query by an additional property in ascending order.
                E.g., query.OrderByDescending((Actor actor) => actor.Name).ThenBy((Actor actor) => actor.Age) generates the cypher:
                ORDER BY actor.name DESC, actor.age.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.ThenByDescending``1(Neo4jClient.Cypher.IOrderedCypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Orders the query by an additional property in descending order.
                E.g., query.OrderBy((Actor actor) => actor.Name).ThenByDescending((Actor actor) => actor.Age) generates the cypher:
                ORDER BY actor.name, actor.age DESC.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.CreateIndex``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Creates a single-property or composite index on properties of a label.
                E.g., query.CreateIndex((Actor actor) => actor.Name) should generate the cypher statement: CREATE INDEX ON
                :Actor(name). This is for a single-property index.
                Likewise, for a composite index, query.CreateIndex((Actor actor) => new { actor.Name, actor.Born }) should generate
                the cypher statement: CREATE INDEX ON :Actor(name, born).
                The examples assume camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.DropIndex``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Drops a single-property or composite index on properties of a label.
                E.g., query.DropIndex((Actor actor) => actor.Name) should generate the cypher statement: DROP INDEX ON
                :Actor(name). This is for a single-property index.
                Likewise, for a composite index, query.DropIndex((Actor actor) => new { actor.Name, actor.Born }) should generate
                the cypher statement: DROP INDEX ON :Actor(name, born).
                The examples assume camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.CreateUniqueConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Creates a uniqueness constraint on a property.
                E.g., query.CreateUniqueConstraint((Actor actor) => actor.Name) generates the cypher: CREATE CONSTRAINT ON
                (actor:Actor) ASSERT actor.name IS UNIQUE.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.DropUniqueConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Drops a uniqueness constraint on a property.
                E.g., query.DropUniqueConstraint((Actor actor) => actor.Name) generates the cypher: DROP CONSTRAINT ON
                (actor:Actor) ASSERT actor.name IS UNIQUE.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.CreateExistsConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Creates an existence constraint on a property.
                E.g., query.CreateExistsConstraint((Actor actor) => actor.Name) generates the cypher: CREATE CONSTRAINT ON
                (actor:Actor) ASSERT exists(actor.name).
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.CreateExistsConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Boolean)">
            <summary>
                Creates an existence constraint on a relationship property.
                E.g., query.CreateExistsConstraint((MovieActorRelationship rel) => rel.Roles, true) generates the cypher: CREATE
                CONSTRAINT ON ()-[rel:ACTED_IN]-() ASSERT exists(rel.roles).
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <param name="isRelationship">
                Set to true if <typeparamref name="T" /> is a relationship model class, else false for
                nodes.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.DropExistsConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Drops an existence constraint on a property.
                E.g., query.DropExistsConstraint((Actor actor) => actor.Name) generates the cypher: DROP CONSTRAINT ON
                (actor:Actor) ASSERT exists(actor.name).
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.DropExistsConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Boolean)">
            <summary>
                Drops an existence constraint on a relationship property.
                E.g., query.DropExistsConstraint((MovieActorRelationship rel) => rel.Roles, true) generates the cypher: DROP
                CONSTRAINT ON ()-[rel:ACTED_IN]-() ASSERT exists(rel.roles).
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property"></param>
            <param name="isRelationship">
                Set to true if <typeparamref name="T" /> is a relationship model class, else false for
                nodes.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.CreateKeyConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Creates a node key constraint on properties of a node.
                E.g., query.CreateKeyConstraint((Actor actor) => new { actor.FirstName, actor.LastName }) generates the cypher:
                CREATE CONSTRAINT ON (actor:Actor) ASSERT (actor.firstName, actor.lastName) IS NODE KEY.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.DropKeyConstraint``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Drops a node key constraint on properties of a node.
                E.g., query.DropKeyConstraint((Actor actor) => new { actor.FirstName, actor.LastName }) generates the cypher: DROP
                CONSTRAINT ON (actor:Actor) ASSERT (actor.firstName, actor.lastName) IS NODE KEY.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.RemoveProperty``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Removes a property/properties from a node.
                E.g., query.RemoveProperty((Actor actor) => actor.Name) generates the cypher: REMOVE actor.name.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property">The property to remove from node.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.RemoveProperty``1(Neo4jClient.Cypher.ICypherFluentQuery,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
                Removes a property/properties from a node.
                E.g., query.RemoveProperty((Actor actor) => actor.Name, "a") generates the cypher: REMOVE a.name.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="property">The property to remove from node.</param>
            <param name="variable">
                >Overrides the parameter used in the predicate lambda. This is useful if the actual variable is
                only known at runtime (dynamic).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.RemoveLabel``1(Neo4jClient.Cypher.ICypherFluentQuery,System.String)">
            <summary>
                Removes the label defined on <typeparamref name="T" /> from the node.
                E.g., query.RemoveLabel&lt;Actor&gt;("actor") generates the cypher: REMOVE actor:Actor.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.RemoveAllLabels``1(Neo4jClient.Cypher.ICypherFluentQuery,System.String)">
            <summary>
                Removes all the labels defined on the <typeparamref name="T" /> type heirarchy from the node.
                E.g., query.RemoveAllLabels&lt;Actor&gt;("actor") generates the cypher: REMOVE actor:Actor:User.
                Example assumes camel casing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="query"></param>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.RemoveMultipleLabels(Neo4jClient.Cypher.ICypherFluentQuery,System.String,System.Type[])">
            <summary>
                Removes the label defined on each specified type in <paramref name="labelTypes" /> from the node.
                E.g., query.RemoveMultipleLabels("actor", typeof(Actor), typeof(MovieExtra)) generates the cypher: REMOVE
                actor:Actor:MovieExtra.
                Example assumes camel casing.
            </summary>
            <param name="query"></param>
            <param name="variable"></param>
            <param name="labelTypes">All label types to be removed.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFluentQueryExtensions.RemoveMultipleLabels(Neo4jClient.Cypher.ICypherFluentQuery,System.String,System.String[])">
            <summary>
                Removes each label specified in <paramref name="labels" /> from the node.
                E.g., query.RemoveMultipleLabels("actor", "Actor", "MovieExtra") generates the cypher: REMOVE
                actor:Actor:MovieExtra.
                Example assumes camel casing.
            </summary>
            <param name="query"></param>
            <param name="variable"></param>
            <param name="labels">All labels to be removed.</param>
            <returns></returns>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.CypherFunctions.Star">
            <summary>
                The neo4j asterisk (*) wildcard.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions._``1(``0)">
            <summary>
                No Further Processing. Naming and other processing escape. This instructs the expression visitors to use as
                specified.
                NOTE: This method does not affect serialization. So inner complex typed properties would still serialize to
                exploded properties as expected.
                This method is mainly used by the expression visitors, and mostly at the top surface level (rarely deep into the
                object).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions._As``1(System.Object)">
            <summary>
                Casts an object to a certain type so as to use its properties directly.
                Use only in expressions, especially with <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> method calls (in which case it
                Pseudo-casts).
                NOTE: THIS METHOD IS NOT SAFE TO EXECUTE. If the cast fails, it merely generates a default value for the return
                type.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions._AsList``1(System.Object)">
            <summary>
                Casts an object to a list of a certain type so as to use IEnumerable extension methods.
                Use only in expressions, especially with <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> method calls (in which case it
                Pseudo-casts).
                Shortcut for <code>._As&lt;List&lt;T&gt;&gt;()</code>
                NOTE: THIS METHOD IS NOT SAFE TO EXECUTE. If the cast fails, it throws an error.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions._AsList``1(``0)">
            <summary>
                Casts an object to a list of a certain type so as to use IEnumerable extension methods.
                Use only in expressions, especially with <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> method calls (in which case it
                Pseudo-casts).
                Shortcut for <code>._As&lt;List&lt;T&gt;&gt;()</code>
                NOTE: THIS METHOD IS NOT SAFE TO EXECUTE. If the cast fails, it merely returns a list having
                <paramref name="obj" /> as only item.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.IsNull``1(``0)">
            <summary>
                The neo4j <code>IS NULL</code> function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.IsNotNull``1(``0)">
            <summary>
                The neo4j <code>IS NOT NULL</code> function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Collect``1(``0)">
            <summary>
                The neo4j collect aggregator.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Length``1(``0)">
            <summary>
                The neo4j length function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Exists``1(``0)">
            <summary>
                The neo4j exists function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Size``1(``0)">
            <summary>
                The neo4j size function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Id``1(``0)">
            <summary>
                The neo4j id function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Type``1(``0)">
            <summary>
                The neo4j type function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Properties``1(``0)">
            <summary>
                The neo4j properties function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Timestamp">
            <summary>
                The neo4j timestamp function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Average``1(``0)">
            <summary>
                The neo4j avg function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Max``1(``0)">
            <summary>
                The neo4j max function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Min``1(``0)">
            <summary>
                The neo4j min function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Sum``1(``0)">
            <summary>
                The neo4j sum function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.StartNode``1(System.Object)">
            <summary>
                The neo4j startNode function
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.EndNode``1(System.Object)">
            <summary>
                The neo4j endNode function
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Count``1(``0)">
            <summary>
                The neo4j count function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Keys``1(``0)">
            <summary>
                The neo4j keys function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Labels``1(``0)">
            <summary>
                The neo4j labels function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Nodes``1(System.Object)">
            <summary>
                The neo4j nodes function.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Relationships``1(System.Object)">
            <summary>
                The neo4j relationships function.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Distinct``1(``0)">
            <summary>
                The neo4j distinct function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Range``2(``0,``1)">
            <summary>
                The neo4j range function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Range``3(``0,``1,``2)">
            <summary>
                The neo4j range function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Tail``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                The neo4j tail function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.StandardDeviation``1(``0)">
            <summary>
                The neo4j stDev function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.StandardDeviationP``1(``0)">
            <summary>
                The neo4j stDevP function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.PercentileCont``2(``0,``1)">
            <summary>
                The neo4j percentileCont function
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TP"></typeparam>
            <param name="source"></param>
            <param name="percentile"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.PercentileDisc``2(``0,``1)">
            <summary>
                The neo4j percentileDisc function
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TP"></typeparam>
            <param name="source"></param>
            <param name="percentile"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.None``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                The neo4j none function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                The neo4j single function.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Rand">
            <summary>
                The neo4j rand function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.E``1(``0)">
            <summary>
                The neo4j e function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Cot``1(``0)">
            <summary>
                The neo4j cot function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Degrees``1(``0)">
            <summary>
                The neo4j degrees function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Haversin``1(``0)">
            <summary>
                The neo4j haversin function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.PI``1(``0)">
            <summary>
                The neo4j pi function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherFunctions.Radians``1(``0)">
            <summary>
                The neo4j radians function
            </summary>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``1(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``1(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``1(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``1(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``1(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``1(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the one-to-one relationship in this pattern. The
                variable used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``2(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="relationship">
                Selects the property that represents the to-many relationship in this pattern. The variable
                used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,System.String,System.String)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern``3(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                P = (A)-[R]-(B).
                To omit any variable, pass empty string or null to it.
                E.g. To omit the first node A in an incoming relationship, pass null to A, and you have ()&lt;-[R]-(B)
            </summary>
            <typeparam name="TANode">The class of Node A. If annotated, information like labels could be gotten from this class.</typeparam>
            <typeparam name="TRel">
                The class of Relationship R. If annotated, information like its type could be gotten from this
                class.
            </typeparam>
            <typeparam name="TBNode">The class of Node B. If annotated, information like labels could be gotten from this class.</typeparam>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="beginRelationship">
                Selects the property that represent the to-many relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Node A.
            </param>
            <param name="endRelationship">
                Selects the property that connects the other node (Node B) of this one-to-one relationship in this pattern.
                The selected property returns, instead of a node class, a dedicated class that is used to represent this
                relationship.
                The variable used in this expression automatically represents Relationship R.
            </param>
            <param name="A">Variable for first node in pattern</param>
            <param name="R">Variable for relationship</param>
            <param name="B">Variable for last node in pattern</param>
            <param name="dir">
                The direction of the relationship, i.e. how the arrow is placed.
                Null value means annotations determine the direction.
                If no annotations, it would default to <see cref="F:Neo4jClient.RelationshipDirection.Outgoing" />
            </param>
            <returns>A source that can allow you match more nodes.</returns>
            <exception cref="T:System.InvalidOperationException">
                Usually happens when all variables are null. In most cases, at least one
                variable should be named.
            </exception>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop(Neo4jClient.DataAnnotations.Cypher.IPatternedPath)">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Int32)">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Int32)">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Int32)">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Int32)">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (A)-[*1..6]-(B)
                Adds variable length relationships where, from the sample, the number of hops would be from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``2,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``2,System.Boolean}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds constraints to the entities.
                Each expression expects simple property comparisons. E.g. A: (actor) =&gt; actor.Name == "Ellen Pompeo" &amp;&amp;
                actor.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, A: (actor) =&gt; actor["Name"] == "Ellen Pompeo" &amp;
                &amp; actor["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: (actor)
                =&gt; actor.movie == CypherVariables.Get("movie")["name"].
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Constraints for Node A.</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (A:Actor {name: "Ellen Pompeo", age: 47})-[R:ACTED_IN {isActive: true}]-(B:Movie {title: "Grey's Anatomy"}).
                Adds properties to the entities. This method should be primarily used with the CREATE clause.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. A: () =&gt; actor, where actor is an instance of the class Actor which has only the properties
                Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, A: () =&gt; new { actor.Name, actor.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. A: () =
                &gt; new { Name = "Ellen Pompeo", Age = CypherVariables.Get("shondaRhimes").As&lt;Writer&gt;().Age }, where
                variable shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="A">Properties for Node A.</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Type,System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Type,System.Type)">
            <summary>
                (A:Label1:Label2)-[R:TYPE1|TYPE2]-(B:Label1:Label2).
                Adds labels in addition to those already marked by attributes. For the relationship, you're adding types, not
                labels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Type,System.Type,System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound(Neo4jClient.DataAnnotations.Cypher.IPatternedPath,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPath{``0,``1,``2},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend(Neo4jClient.DataAnnotations.Cypher.IPath,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``1(Neo4jClient.DataAnnotations.Cypher.IPath,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``1(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``1(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``2(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Extend``3(Neo4jClient.DataAnnotations.Cypher.IPath,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C).
                Extends an existing path.
                From the sample, B is the new A for this method, R2 is the new R, and C is the new B.
                Because this new A here (which is also the old B) has earlier on been represented in this pattern, the expression
                here does not consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Label``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
                (B)-[R2:TYPE1|TYPE2]-(C:Label1:Label2).
                Adds labels to the pattern extension, in addition to those already marked by attributes. For the relationship,
                you're adding types, not labels.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension)">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Int32)">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Int32)">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Int32)">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Int32)">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Int32)">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Hop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                (B)-[:*1..6]-(C)
                Adds variable length relationships to the pattern extension where, from the sample, the number of hops would be
                from 1 (min), to 6 (max).
                To remove either hop variable, pass <c>null</c> to the variable. E.g. Omitting 1 means [*..6] which also means no
                lower bound.
                For fixed number of hops, pass the same value to the <paramref name="from" /> and <paramref name="to" /> variables,
                or use method provided. E.g. passing 6 and 6 means [*6]
                For unbounded hops, that is, Cypher considers any number of hops possible (usually not advised), pass <c>null</c>
                to both variables, or use the no variable method. E.g passing null means [*]
            </summary>
            <param name="exact">Fixed number of hops to consider.</param>
            <param name="from">Minimum number of hops to consider.</param>
            <param name="to">Maximum number of hops to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Linq.Expressions.Expression{System.Func{Neo4jClient.DataAnnotations.CypherObject,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{``2,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Constrain``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{``1,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``2,System.Boolean}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds constraints to the entities of the pattern extension.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects simple property comparisons. E.g. B: (writer) =&gt; writer.Name == "Shonda Rhimes" &amp;
                &amp; writer.Age == 47.
                When the <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> is used, it becomes, B: (writer) =&gt; writer["Name"] == "Shonda Rhimes" &amp;
                &amp; writer["Age"] == 47.
                This example would generate the sample Cypher predicate shown previously.
                NOTE that only the LOGICAL AND operator (&amp;&amp;) is expected in the expressions. Any other operators used would
                either be ignored, or result in an exception being thrown.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Constraints for Relationship R.</param>
            <param name="B">Constraints for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Prop``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Linq.Expressions.Expression{System.Func{System.Object}},System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
                (B)-[R2:WROTE {isActive: true}]-(C:Writer {name: "Shonda Rhimes"}).
                Adds properties to the entities of the pattern extension. This method should be primarily used with the CREATE
                clause.
                Remember that, from the sample, B is our new A for this method (and hence omitted), R2 is new R, and C is new B.
                Each expression expects a return instance of the entity type, or an anonymous object declaring specific properties
                to serialize. E.g. B: () =&gt; writer, where writer is an instance of the class Writer which has only the
                properties Name and Age.
                If <see cref="T:System.Object" /> type is used, it becomes, B: () =&gt; new { writer.Name, writer.Age }.
                This example would generate the sample Cypher predicate shown previously.
                You can also introduce previously declared variables with the <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class. E.g. B: () =
                &gt; new { Name = "Shonda Rhimes", Age = CypherVariables.Get("ellenPompeo").As&lt;Actor&gt;().Age }, where variable
                shondaRhimes was declared possibly in a previous Cypher clause.
                NOTE that all properties on any instance supplied will be serialized. If you need only a select few properties,
                declare an anonymous type instead.
            </summary>
            <param name="source">Path object from the calling cypher clause</param>
            <param name="R">Properties for Relationship R.</param>
            <param name="B">Properties for Node B.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Type,System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Type``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Type,System.Type)">
            <summary>
                Changes the node's c# type at runtime. However, ensure that this new type can be assigned to the type specified at
                compile time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension,System.Nullable{System.Boolean},System.Nullable{System.Boolean})" -->
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``1(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``2(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{Neo4jClient.DataAnnotations.CypherObject,``0,``1},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.AlreadyBound``3(Neo4jClient.DataAnnotations.Cypher.IPatternedPathExtension{``0,``1,``2},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
                Instead of (A:Label1:Label2), you get (A). This is especially useful in MERGE statements.
                Specifies that a variable is already bound in the query so as to skip its labels and properties in the pattern.
                Assign <code>null</code> if you want the pattern to attempt to decide this for itself instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend(Neo4jClient.DataAnnotations.Cypher.IPathExtension,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``1(Neo4jClient.DataAnnotations.Cypher.IPathExtension,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``1(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``1(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``2(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String,System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.ThenExtend``3(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String,Neo4jClient.RelationshipDirection)">
            <summary>
                (A)-[R]-(B)-[R2]-(C)-[R3]-(D).
                Extends an existing path even further.
                From the sample, C will be the new A for this method, R3 is the new R, and D is the new B.
                Because this new A (that is, C) has earlier on been represented in this pattern, the expression here does not
                consider the new A.
                Instead, it proceeds with new R, and new B. The method variables here work like they do in the
                <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Pattern(Neo4jClient.DataAnnotations.Cypher.IPathBuilder,System.String)" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Shortest(Neo4jClient.DataAnnotations.Cypher.IPath)">
            <summary>
                P = shortestPath((A)-[R]-(B)).
                Calls the shortestPath function on the generated pattern.
                Note that Cypher allows only non-extended simple patterns for the shortestPath function.
                Also note that this method implicitly calls the <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPath)" /> method because invoking the shortestPath
                function more likely means you need the path returned.
                Calling <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPath)" /> means this should be the last method called on the pattern.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Shortest(Neo4jClient.DataAnnotations.Cypher.IPath,System.String)">
            <summary>
                P = shortestPath((A)-[R]-(B)).
                Calls the shortestPath function on the generated pattern.
                Note that Cypher allows only non-extended simple patterns for the shortestPath function.
                Also note that this method implicitly calls the <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPath)" /> method because invoking the shortestPath
                function more likely means you need the path returned.
                Calling <see cref="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPath)" /> means this should be the last method called on the pattern.
            </summary>
            <param name="source"></param>
            <param name="pathVariable">
                Use this to override the path variable (which is default to the lambda expression
                parameter).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPath)">
            <summary>
                Assigns the entire pattern to the path variable.
                That is, P = (A)-[R]-(B),
                where P is the path variable as defined by the lambda expression variable of type <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" /> that
                generated this pattern.
                For example, Match((path) =&gt; path.Pattern("user").Assign()) would generate the Cypher: MATCH path = (user).
                Note that whenever the path variable is required, always make this the last method called on the
                <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" />.
                Without this method being called, the generated pattern would not be assigned to a path variable.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPath,System.String)">
            <summary>
                Assigns the entire pattern to the path variable.
                That is, P = (A)-[R]-(B),
                where P is the path variable as defined by the lambda expression variable of type <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" /> that
                generated this pattern.
                For example, Match((path) =&gt; path.Pattern("user").Assign()) would generate the Cypher: MATCH path = (user).
                Note that whenever the path variable is required, always make this the last method called on the
                <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" />.
                Without this method being called, the generated pattern would not be assigned to a path variable.
            </summary>
            <param name="source"></param>
            <param name="pathVariable">
                Use this to override the path variable (which is default to the lambda expression
                parameter).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPathExtension)">
            <summary>
                Assigns the entire pattern to the path variable.
                That is, P = (A)-[R]-(B),
                where P is the path variable as defined by the lambda expression variable of type <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" /> that
                generated this pattern.
                For example, Match((path) =&gt; path.Pattern("user").Assign()) would generate the Cypher: MATCH path = (user).
                Note that whenever the path variable is required, always make this the last method called on the
                <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" />.
                Without this method being called, the generated pattern would not be assigned to a path variable.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.Assign(Neo4jClient.DataAnnotations.Cypher.IPathExtension,System.String)">
            <summary>
                Assigns the entire pattern to the path variable.
                That is, P = (A)-[R]-(B),
                where P is the path variable as defined by the lambda expression variable of type <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" /> that
                generated this pattern.
                For example, Match((path) =&gt; path.Pattern("user").Assign()) would generate the Cypher: MATCH path = (user).
                Note that whenever the path variable is required, always make this the last method called on the
                <see cref="T:Neo4jClient.DataAnnotations.Cypher.IPathBuilder" />.
                Without this method being called, the generated pattern would not be assigned to a path variable.
            </summary>
            <param name="source"></param>
            <param name="pathVariable">
                Use this to override the path variable (which is default to the lambda expression
                parameter).
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherPathExtensions.SharedPattern``3(Neo4jClient.DataAnnotations.Cypher.IPathable,System.String,System.String,System.String,System.Nullable{Neo4jClient.RelationshipDirection},System.Boolean)">
            <summary>
                This method should always be called for new patterns.
            </summary>
            <typeparam name="TANode"></typeparam>
            <typeparam name="TRel"></typeparam>
            <typeparam name="TBNode"></typeparam>
            <param name="source"></param>
            <param name="A"></param>
            <param name="R"></param>
            <param name="B"></param>
            <param name="dir"></param>
            <param name="testARBForNull"></param>
            <returns></returns>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.CypherVariables">
            <summary>
                All-purpose class for getting variables already declared in a Cypher query.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherVariables.Get(System.String)">
            <summary>
                Gets a variable as <see cref="T:Neo4jClient.DataAnnotations.CypherObject" />. Properties of the variable can be accessed from the
                <see cref="T:Neo4jClient.DataAnnotations.CypherObject" /> returned.
                E.g. (Actor actor) =&gt; actor.Movie == CypherVariables.Get("movie")["name"].
            </summary>
            <param name="name">The name of the variable or expression to get</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherVariables.Get``1(System.String)">
            <summary>
                Shortcut for getting a variable as a certain type.
                For example, CypherVariables.Get&lt;User&gt;("user").Name, is the exact same as CypherVariables.Get("user")["name"]
                ... assuming camel case serialization.
            </summary>
            <typeparam name="TResult">The type of variable or expression to return.</typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.CypherVariables.Get``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Shortcut for getting a variable or expression as a certain type.
                For example, CypherVariables.Get&lt;User, string&gt;(user => user.Address.City).Name, is the exact same as
                CypherVariables.Get&lt;string&gt;("user.address_city")... assuming camel case serialization.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult">The type of variable or expression to return.</typeparam>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.EntityService">
            <summary>
                This class provides entity information.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.EntityService.AddEntityType(System.Type)">
            <summary>
                Registers a <see cref="T:System.Type" /> with Neo4jClient.DataAnnotations.
                This method also autmatically adds contained complex types. However, derived and/or base types must be added
                independently.
            </summary>
            <param name="entityType"></param>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.EntityService.GetDerivedEntityTypes(System.Type)">
            <summary>
                Retrieves all types that can be assigned to the particular baseType (and not just its direct subclasses).
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.EntityExpressionVisitor.GetNewExpressionItems(System.Linq.Expressions.NewExpression)">
            <summary>
                Converts an anonymous new expression to dictionary items
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.ExpressionUtilities.GetVariableExpressions``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},Neo4jClient.DataAnnotations.Cypher.QueryContext,System.Boolean,System.String,Neo4jClient.DataAnnotations.Expressions.FunctionVisitorContext)">
            <summary>
                Expecting:
                a =&gt; a.Property //member access = "a.property"//
                a =&gt; new { a.Property1, a.Property2 } //multiple member accesses = "a.property1", "a.property2"//
                a =&gt; a.Property.ToString() //complex expression (i.e., member access with function calls) =
                "toString(a.property)"//
                a =&gt; new { a.Property1, Property2 = a.Property2.Length } //multiple complex expressions = "a.property1",
                "size(a.property2)"//
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expressions"></param>
            <param name="isMemberAccess">If false, the variable is not included</param>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.ExpressionUtilities.GetVariableExpressions(System.Type,System.Linq.Expressions.LambdaExpression,Neo4jClient.DataAnnotations.Cypher.QueryContext,System.Boolean,System.String,Neo4jClient.DataAnnotations.Expressions.FunctionVisitorContext)">
            <summary>
                Expecting:
                a =&gt; a.Property //member access = "a.property"//
                a =&gt; new { a.Property1, a.Property2 } //multiple member accesses = "a.property1", "a.property2"//
                a =&gt; a.Property.ToString() //complex expression (i.e., member access with function calls) =
                "toString(a.property)"//
                a =&gt; new { a.Property1, Property2 = a.Property2.Length } //multiple complex expressions = "a.property1",
                "size(a.property2)"//
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expressions"></param>
            <param name="isMemberAccess">If false, the variable is not included</param>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Expressions.FunctionExpressionVisitor.DefaultBinaryOperators">
            <summary>
                Add more as you need, as long as it is binary
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Expressions.FunctionExpressionVisitor.DefaultLeftAlignedUnaryOperators">
            <summary>
                Add more as you need, as long as it is left-aligned unary i.c., the operator appears on the left of the operand.
                c.g. NOT operand
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Expressions.FunctionExpressionVisitor.DefaultRightAlignedUnaryOperators">
            <summary>
                Add more as you need, as long as it is right-aligned unary i.c., the operator appears on the right of the operand.
                c.g. operand?
                Usually right-aligned operators do not have spaces between them and their operands, so no space inputed here.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionExpressionVisitor.ProcessUnhandledSimpleVars(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
                Don't call this method directly unless you wan't to force this process
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionExpressionVisitor.InvokeHandler(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext,System.Func{System.Linq.Expressions.Expression})">
            <summary>
                This will invoke the specified handler.
            </summary>
            <param name="handler"></param>
            <param name="node"></param>
            <param name="continuation"></param>
            <returns></returns>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext.Visitor">
            <summary>
                The Visitor is only available when the handler is finally executed, and not at the test phase.
            </summary>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext.Continuation">
            <summary>
                The Continuation delegate is only available when the handler is finally executed, and not at the test phase.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.ParameterNodeType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Rewrites the Parameter Expression as a CypherVariables.Get method call.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.ConstantNodeType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes a constant.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.NullOperandEqualNodeType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Rewrites the Equal Node Type with Null Operand as IS NULL.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.NullOperandNotEqualNodeType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Rewrites the NotEqual Node Type with Null Operand as IS NOT NULL.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.IsNull(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>IS NULL</code> neo4j function
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.IsNotNull(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>IS NOT NULL</code> neo4j function
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.BinaryType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the binary operators
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.UnaryType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the unary operators
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.New_Dictionary_MemberInitType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Treats a <see cref="T:System.Linq.Expressions.MemberInitExpression" />, dictionary <see cref="T:System.Linq.Expressions.ListInitExpression" />, or a generic
                <see cref="T:System.Linq.Expressions.NewExpression" /> as a constant, or nothing, as may be appropriate.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.NewArrayType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> as a neo4j array.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.NoFurtherProcessing(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Skips the No-Further-Processing method (<see cref="!:HelperExtensions._&lt;T&gt;(T)" />) in an expression.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.StringComparison(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext,System.String,System.String)">
            <summary>
                Writes the neo4j string comparison functions like <code>STARTS WITH</code>.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.CypherListComprehensionBody(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression,Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                cypherMethod(variable IN source WHERE predicate | selector)
            </summary>
            <param name="cypherMethod"></param>
            <param name="predicateExpr"></param>
            <param name="context"></param>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.CypherListPredicate(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext,System.String,System.String,System.Type)">
            <summary>
                method(source, (variable) => predicate)
                would be: cypherMethod(variable IN source WHERE predicate)
            </summary>
            <param name="context"></param>
            <param name="method"></param>
            <param name="cypherMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.CypherListSelector(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext,System.String,System.String,System.Type)">
            <summary>
                method(source, (variable) => selector)
                would be: cypherMethod(variable IN source | selector)
            </summary>
            <param name="context"></param>
            <param name="method"></param>
            <param name="cypherMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.CollectionContains(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>IN</code> neo4j function.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.Aggregate(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>reduce</code> neo4j list function.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.Concat(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>+</code> neo4j list function.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.Union(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Concatenates a list. Same as Concat.
                NOTE: THIS IS NOT THE UNION CLAUSE. THIS WORKS ON ONLY LISTS, AND NOT ROWS. IT ALSO DOES NOT GUARANTEE DISTINCT
                VALUES.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.Intersect(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Filters each element contained in both lists.
                NOTE: THIS WORKS ON ONLY LISTS, AND NOT ROWS. IT ALSO DOES NOT GUARANTEE DISTINCT VALUES.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.Distinct(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>DISTINCT</code> neo4j function.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.CoalesceNodeType(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>coalesce</code> neo4j scalar function.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.CollectionCount(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                This produces size(). For count() use .Count().
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.ConvertMethod(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext,System.String,System.String)">
            <summary>
                Writes the convert neo4j scalar functions.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.EmptyAny(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>any</code> neo4j predicate function with a random variable checking for the first non-null object.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Expressions.FunctionHandlers.EnumerableContains(Neo4jClient.DataAnnotations.Expressions.FunctionHandlerContext)">
            <summary>
                Writes the <code>exists</code> neo4j predicate function.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="P:Neo4jClient.DataAnnotations.Expressions.FunctionVisitorContext.Misc">
            <summary>
                Any other information/options that may be needed by methods should be added here.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.GetAnnotationsContext(Neo4jClient.IGraphClient)">
            <summary>
                Gets the <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> attached to the <see cref="T:Neo4jClient.IGraphClient" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns>Returns an instance of <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> or null if not found.</returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations(Neo4jClient.IGraphClient)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a resolver of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a resolver of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations``1(Neo4jClient.IGraphClient)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a resolver of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations``1(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a resolver of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations``2(Neo4jClient.IGraphClient)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" />
                using a resolver of type <typeparamref name="TResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations``2(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" />
                using a resolver of type <typeparamref name="TResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotations``2(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService,``0@)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" />
                using a resolver of type <typeparamref name="TResolver" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <param name="context">The newly created <typeparamref name="TContext" />.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter(Neo4jClient.IGraphClient)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a converter of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a converter of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter``1(Neo4jClient.IGraphClient)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a converter of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter``1(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" /> to the
                <see cref="T:Neo4jClient.IGraphClient" />
                using a converter of type <see cref="T:Neo4jClient.DataAnnotations.Serialization.EntityConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter``2(Neo4jClient.IGraphClient)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" />
                using a converter of type <typeparamref name="TConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter``2(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" />
                using a converter of type <typeparamref name="TConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.GraphClientExtensions.WithAnnotationsConverter``2(Neo4jClient.IGraphClient,Neo4jClient.DataAnnotations.EntityService,``0@)">
            <summary>
                Attaches an <see cref="T:Neo4jClient.DataAnnotations.AnnotationsContext" /> of type <typeparamref name="TContext" />
                using a converter of type <typeparamref name="TConverter" />.
            </summary>
            <param name="graphClient">The graph client.</param>
            <param name="entityService">
                The service that provides entity information. Ideally, only one instance of <see cref="T:Neo4jClient.DataAnnotations.EntityService" /> should
                exist.
                This parameter is optional and can be null, however, you can get a new instance from
                <see cref="M:Neo4jClient.DataAnnotations.AnnotationsContext.CreateNewEntityService" />.
            </param>
            <param name="context">The newly created <typeparamref name="TContext" />.</param>
            <returns></returns>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.NeoNonScalarAttribute">
            <summary>
                All structs and enums are assumed to be scalars that can be serialized to Neo4j.
                Use this attribute on any struct or enum to indicate otherwise.
                Alternatively, you can add such struct or enum or any other type to
                <see cref="P:Neo4jClient.DataAnnotations.EntityService.KnownNonScalarTypes" /> list instead.
            </summary>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.NeoScalarAttribute">
            <summary>
                All classes and interfaces are assumed to be non-scalars (i.e. navigational) that cannot be serialized to Neo4j.
                Use this attribute on any class or interface to indicate otherwise.
                Alternatively, you can add such class or interface or any other type to
                <see cref="P:Neo4jClient.DataAnnotations.EntityService.KnownScalarTypes" /> list instead.
            </summary>
        </member>
        <member name="T:Neo4jClient.DataAnnotations.Serialization.EntityResolverConverter">
            <summary>
                Converter used in using the Resolver mode for deserialization because Neo4jClient currently uses converters when
                deserializing.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.EntityTypeInfo.GetForeignKeysWithAttribute(System.Type)">
            <summary>
                Gets properties that have specific attribute on either the scalar or nav property of a foreign key.
            </summary>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.Extensions.UncastBox(System.Linq.Expressions.Expression,System.Type@,System.Type)">
            <summary>
                Removes cast around an expression only if the cast was a boxing operation.
            </summary>
            <param name="expression"></param>
            <param name="castRemoved"></param>
            <param name="castToRemove"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.Extensions.ToJToken(System.String)">
            <summary>
                Converts a string value to its appropriate <see cref="T:Newtonsoft.Json.Linq.JToken" /> or <see cref="T:Newtonsoft.Json.Linq.JRaw" />.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.Utilities.GetLabels(System.Type,System.Boolean)">
            <summary>
                Gets all the <see cref="T:System.ComponentModel.DataAnnotations.Schema.TableAttribute" /> names on the class inheritance as labels.
                Should none be gotten, the type name is used instead by default.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.Utilities.GetLabel(System.Type,System.Boolean)">
            <summary>
                Gets the <see cref="T:System.ComponentModel.DataAnnotations.Schema.TableAttribute" /> name on the specified class as a label.
                Should none be gotten, the type name is used instead by default.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.Utilities.HasNfpEscape(System.Linq.Expressions.Expression)">
            <summary>
                No further processing escape
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Neo4jClient.DataAnnotations.Utils.Utilities.GetValue``1(System.Int32)">
            <summary>
                Placeholder method for <see cref="T:Neo4jClient.DataAnnotations.CypherVariables" /> class calls in expressions.
            </summary>
            <typeparam name="TReturn">The last return type of the contiguous access stretch.</typeparam>
            <param name="index">The index of the actual expression in the store.</param>
            <returns>A default value of the return type.</returns>
        </member>
    </members>
</doc>
